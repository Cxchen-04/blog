---
title: MCP 大模型上下文协议
date: 2025-06-12 18:11:27
tags: [大模型, 协议]
categories: [AI, MCP]
---

## 背景

随着各类大型语言模型逐渐走向实际应用，如何在不同模型、不同服务之间传递并维护上下文成为新的挑战。传统的 API 更多关注单次请求与响应，但在多轮对话以及长时间会话的场景下，缺乏统一的上下文管理手段往往导致模型理解偏差或状态错乱。MCP（Model Context Protocol）正是在这样的需求下提出的一套标准化协议，旨在规范大模型在生成式对话中的上下文表示与交互方式。

## 协议目标

1. **统一表示**：提供一套通用的数据结构，描述对话双方的消息、会话标识以及额外的环境信息。
2. **跨模型兼容**：不同模型或服务遵循 MCP 后，可以方便地在链路中转发或组合使用，提高生态可扩展性。
3. **可追溯性**：通过上下文节点的引用与版本控制，便于审计、回溯和调试。

## 协议结构

### 核心概念

- **Conversation**：一次完整的会话，拥有唯一的会话 ID 和若干上下文节点。
- **ContextNode**：会话中某一轮对话的记录，包含消息内容、角色信息以及关联的元数据。
- **Metadata**：可选的附加字段，用于存储模型设置、温度参数、插件状态等。

### 消息结构

```json
{
  "conversation_id": "123456",
  "nodes": [
    {
      "id": "node1",
      "role": "user",
      "content": "你好，MCP 是什么？",
      "timestamp": 1718200000
    },
    {
      "id": "node2",
      "role": "assistant",
      "content": "MCP 是一种用于管理大模型对话上下文的协议。",
      "parent": "node1",
      "timestamp": 1718200001
    }
  ]
}
```

上述示例展示了最基础的 MCP 对话格式：每个节点可以通过 `parent` 字段关联上一条消息，从而形成一棵有序的对话树。对于需要分支或多轮引用的场景，可以在节点中添加 `reference` 列表，指向相关的历史节点。

### 上下文管理

实现 MCP 的系统通常会在服务端维护完整的节点链，并在请求时带上所需的上下文片段。客户端只需关心当前会话编号和最新的节点 ID，由服务端按照协议拼接完整的上下文后送入模型。这样既避免了客户端重复传输大量历史记录，也能保障模型始终获得正确的会话状态。

## 参考实现

目前 MCP 在一些开源社区中已有初步的实现，例如基于 Node.js 的 `mcp-js` 框架，通过中间件形式在每次请求前后自动写入与读取上下文节点。服务端可以将节点存储在数据库或内存中，并提供查询接口供其他业务系统调用。对于模型侧，只需在推理前解析 MCP 格式的输入，按顺序拼接内容即可完成上下文构建。

## 与现有系统的区别

与传统的 REST 或 WebSocket 对话接口相比，MCP 更强调统一的上下文表达和完整的节点关系。它不仅关注当前请求，还描述了消息之间的层级和依赖，使得对话流在跨模型、跨服务的场景下依然能够保持一致。通过显式的 `conversation_id`、`node.id` 与 `parent` 关系，开发者可以非常直观地追踪一次对话的演进过程。

## 未来展望

随着多模态模型以及复杂插件生态的出现，对话上下文中可能会包含图片、语音甚至结构化的调用结果。MCP 的开放性设计能够通过扩展 `Metadata` 和节点类型来适应新的需求。未来，若更多厂商与社区采纳 MCP，大模型在实际应用中的协同与可控性将得到显著提升。

