[{"title":"你好，我的第一篇blog","url":"/2025/03/19/hello-world/","content":"欢迎光临chen的博客！这是我的第一篇文章。查看[介绍]获取更多信息。如果你在使用我的网站时遇到任何问题，你可以在[故障排除]中找到答案，或者你可以在GitHub上问我。\n快速开始创建一篇博客$ hexo new &quot;My New Post&quot;\n\n更多信息: 文章\n运行服务器$ hexo server\n\n更多信息: 服务端\n生成静态文件$ hexo generate\n\n更多信息: 生成\n部署到远程仓库$ hexo deploy\n\n更多信息: 部署\n"},{"title":"Python","url":"/2025/03/26/Python/","content":"","categories":["服务端","Python"],"tags":["服务端，Python"]},{"title":"Shell","url":"/2025/03/26/Shell/","content":"","categories":["服务端","Shell"],"tags":["服务端","Shell"]},{"title":"Docker","url":"/2025/03/25/docker/","content":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n简介容器技术不仅限于docker，但是docker目前最为流行，docker容器技术的核心之一在于镜像文件。镜像文件，通俗的理解就是一个进程运行时依赖的软件文件的集装箱。\n  应用集群部署时，每台机器首先会拉取指定版本的镜像文件。安装镜像后产生了docker容器。由于所有机器的镜像文件一样，容器的软件版本故而一样。即使开发或运维中途修改了容器的软件版本，但是容器销毁时，软件的改动会随容器的销毁一起湮灭。当应用用已有的镜像文件重新部署时，生成的docker容器跟修改之前的容器完全一样。这也是Infrastructure as code思想带来的好处。\n  容器如果要升级软件版本，那就修改镜像文件。这样部署时集群内所有的机器重新拉取新的镜像，软件因此跟着一起升级。软件版本混乱的问题，到docker这里，也就得到了完美的解决。\n一个疑问：有了容器技术，生产环境为何还需要部署虚拟机？\n虚拟机能做到硬件资源的彻底隔离，docker不行。虚拟机 和 docker各取长处，最佳CP。\n安装docker解决国内Docker镜像问题由于2024年6月开始国内的大量docker镜像停服😤，Docker无法下载安装😭此仓库致力于解决国内网络原因无法使用Docker的问题使用Github Action将官网的安装脚本&#x2F;安装包定时下载到本项目Release，供国内使用官方安装包，安全可靠每天自动定时同步，保证最新作者：技术爬爬虾B站，抖音，Youtube全网同名，转载请注明作者\nLinuxsudo curl -fsSL https://get.docker.com| bash -s docker --mirror Aliyun #一键安装命令sudo curl -fsSL https://github.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun# 备用命令（每天自动从官网定时同步）sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun# 备用2 （如果github访问不了，可以使用gitee的链接）sudo service docker start #启动Docker\n\nCentos安装dockerCentOS 7或更高版本必须启用CentOS Extras存储库。默认情况下，此存储库已启用，但如果已禁用，则需要 重新启用它。建议使用overlay2存储驱动程序。如果以前安装的老版本（Docker名称是docker或docker-engine）请先删除\ncentOSsudo yum remove docker \\docker-client \\docker-client-latest \\docker-common \\docker-latest \\docker-latest-logrotate \\docker-logrotate \\docker-engine\n上述操作只会删除docker本身，但老版本保存在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;的内容，包括镜像、容器、卷和网络需要手动删除。\n安装方式1.脚本安装(多用于测试和开发环境)\ncentOScurl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh\n\n2.使用仓库安装(推荐)2.1设置docker仓库\ncentOSsudo yum install -y yum-utils \\device-mapper-persistent-datalvm2sudo yum-config-manager \\--add-repo \\https://download.docker.com/linux/centos/docker-ce.repo\n2.2安装docker CE\ncentOSsudo yum install docker-ce docker-ce-cli container.io # 安装最新的Docker CE版本yum list docker-ce --showduplicates | sort -rsudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; container.io#说明：&lt;VERSION_STRING&gt;，取上图中第二列中的第一个：或第一个数字到-之间的字符串，如18.09.6、18.06.2.ce等。\n\n3.使用RPM程序包安装（适用于没有互联网接入的情况）3.1下载所需要的Docker版本下载地址： https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\ncentOSsudo yum install /path/to/package.rpm# 其中/path/to/package.rpm,为你下载下来的rpm包所在位置和文件名称sudo systemctl start docker# 启动Dockersudo docker run hello-world# 验证安装是否正确\n更多信息: Centos安装docker\nUbuntu安装dockerDocker 需要在64位版本的Ubuntu上安装。此外，你还需要保证你的 Ubuntu 内核的最小版本不低于 3.10，其中3.10 小版本和更新维护版也是可以使用的。\nUbuntuuname -r 3.11.0-15-generic\n\nUbuntuwhich wget # 查看你是否安装了wgetsudo apt-get update sudo apt-get install wget # 如果wget没有安装，先升级包管理器，然后再安装它。wget -qO- https://get.docker.com/ | sh  # 获取最新版本的 Docker 安装包sudo docker run hello-world  # 验证 Docker 是否被正确的安装 # 上边的命令会下载一个测试镜像，并在容器内运行这个镜像\n更多信息: Ubuntu安装docker\nMacos安装dockerHomebrew 的 Cask 已经支持 Docker for Mac\nMacosbrew cask install docker\n在载入 Docker app 后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有有个小鲸鱼的图标（）。\n更多信息: Macosa安装docker\n使用dockerPull镜像方案一 转存到阿里云使用github Action将国外的Docker镜像转存到阿里云私有仓库，供国内服务器使用，免费易用支持DockerHub, gcr.io, k8s.io, ghcr.io等任意仓库支持最大40GB的大型镜像使用阿里云的官方线路，速度快项目地址: Github\n方案二 镜像站现在只有很少的国内镜像站存活不保证镜像齐全,且用且珍惜以下三个镜像站背靠较大的开源项目，优先推荐\n\n\n\n项目名称\n项目地址\n加速地址\n\n\n\n1Panel\nhttps://github.com/1Panel-dev/1Panel/\nhttps://docker.1panel.live\n\n\nDaocloud\nhttps://github.com/DaoCloud/public-image-mirror\nhttps://docker.m.daocloud.io\n\n\n耗子面板\nhttps://github.com/TheTNB/panel\nhttps://hub.rat.dev\n\n\nlinux配置镜像站\nLinuxsudo vi /etc/docker/daemon.json #创建/打开daemon文件&#123;    &quot;registry-mirrors&quot;: [        &quot;https://docker.m.daocloud.io&quot;,        &quot;https://docker.1panel.live&quot;,        &quot;https://hub.rat.dev&quot;    ]&#125;# 输入以上内容，vi按esc，输入:wq保存  nano输入ctrl+x保存退出sudo service docker restart # 重启docker\n\n方案三 离线镜像使用Github Action下载docker离线镜像 https://github.com/wukongdaily/DockerTarBuilder\n方案四 使用一键脚本dockerbash -c &quot;$(curl -sSLf https://xy.ggbond.org/xy/docker_pull.sh)&quot; -s 完整镜像名\n方案五 使用Cloudflare worker 自建镜像加速https://github.com/cmliu/CF-Workers-docker.io\n去哪里找镜像https://docker.fxxk.dedyn.io/\n更多信息: Github Action\n常用的操作命令Docker Dockerfile一、什么是 Dockerfile？Dockerfile 是一套“食谱”，告诉 Docker 如何构建你的镜像。通过它，你可以：    •\t指定用哪个基础镜像（比如 Python、Node、Nginx）    •\t安装依赖    •\t拷贝文件    •\t执行命令    •\t设置运行服务时的默认命令\n二、Dockerfile 语法结构（超清晰版）# 1. 指定基础镜像（必须有）FROM 镜像名[:tag]# 2. 设置容器中的工作目录（可选）WORKDIR /app# 3. 拷贝文件到镜像中COPY ..# 4. 安装依赖（可多条RUN）RUN 命令# 5. 设置环境变量（可选）ENV 变量名=值# 6. 设置容器启动时执行的命令CMD [&quot;命令&quot;,&quot;参数&quot;]# 7. 设置暴露的端口（可选，用于文档提升）EXPOSE 端口号\n三、最常见的语句详解 + 示例\n\n\n指令\n示例\n说明\n\n\n\nFROM\nFROM node:18\n基础镜像\n\n\nWORKDIR\nWORKDIR &#x2F;app\n切换目录（类似 cd）\n\n\nCOPY\nCOPY . .\n将当前目录复制到容器里\n\n\nRUN\nRUN npm install\n构建期间执行命令\n\n\nCMD\nCMD [“npm”, “start”]\n容器启动时运行（只能有一条）\n\n\nEXPOSE\nEXPOSE 3000\n说明服务监听的端口（仅文档提示）\n\n\n四、实战示例：Flask Web App📁 项目结构：\nmy-flask-app/├── app.py├── requirements.txt└── Dockerfile\n📄 app.py：\nfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def home():    return &quot;Hello,Docker!&quot;if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;,port=5000)\n📄 requirements.txt：\nflask\n📄 Dockerfile：\nFROM python:3.9-slimWORKDIR /appCOPY ..RUN pip install -r requirements.txtEXPOSE 5000CMD [&quot;python&quot;,&quot;app.py&quot;]\n🛠 构建镜像并运行：\ndocker build -t my-flask-app .docker run -d -p 5000:5000 my-flask-app\n浏览器访问：http://localhost:5000🎉 成功！\n五、常见问题与技巧\n\n\n问题\n原因与解决方式\n\n\n\n容器运行后马上退出\nCMD 写错或服务没启动\n\n\n镜像太大\n换用 -slim、-alpine 镜像\n\n\n文件没拷进去\nCOPY 路径写错、.dockerignore 把它排除了\n\n\n构建慢\n用 .dockerignore 排除不必要的文件（比如 node_modules）\n\n\n六、Dockerfile 小技巧合集# 编译阶段FROM node:18 as buildWORKDIR /appCOPY ..RUN nom install &amp;&amp; npm run build# 部署阶段（nginx）FROM nginxCOPY --from=build /app/dist /usr/share/nginx/html#设置环境变量ENV PORT=8080\n最后送你一句口诀 🧠FROM 定基础，WORKDIR 定位置，COPY 拷代码，RUN 装环境，CMD 启动它。\nDocker Compose一、Docker Compose是什么？他是一个docker-compose.yml文件：    •\t描述多个服务（比如 web、db、redis）    •\t指定端口、挂载、网络、环境变量等    •\t一条命令就能启动：docker-compose up\n二、基本语法结构version: &#x27;3&#x27;    #Compose文件版本,一般用‘3’或‘3.8’services:       #定义所有容器服务    服务名1:        image: 镜像名 或 buld路径        ports:            - &quot;本地端口：容器端口&quot;        volumes:            - &quot;本地路径：容器路径&quot;        environment:            - &quot;变量名=值&quot;        depends_on:            - 其他服务名（启动顺序）    服务名2:        ....\n三、最简单示例：部署一个带自定义挂载的 Nginxmy-compose-project/├── docker-compose.yml├── html/│   └── index.html└── nginx.conf\n📄 docker-compose.yml 内容：\nversion: &#x27;3&#x27;services:  web:    image: nginx    ports:      - &quot;8080:80&quot;    volumes:      - ./html:/usr/share/nginx/html:ro      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n📌说明：    •\t端口映射：8080 → 容器内80    •\t挂载本地 .&#x2F;html 到 nginx 的网页根目录    •\t挂载本地配置文件替换默认 nginx 配置✅ 启动：\nUbuntudocker-compose up -d # 或者 docker compose up -d\n✅ 停止：\nUbuntudocker-compose down -v # 或者 docker compose down -v\n四、多服务组合示例（Node.js + MongoDB）version: &#x27;3&#x27;services:    app:        build: .        ports:            - &quot;3000:3000&quot;        environment:            - MONGO_URL=mongodb://mongo:27017/mydb        depends_on:            - mongo        mongo:        image: mongo        ports:            - &quot;27017:27017&quot;\n📌说明：    •\tapp 服务用 Dockerfile 构建    •\t依赖 Mongo 容器，并通过服务名 mongo 进行连接\n五、常见字段说明（适合记住）\n\n\n字段\n用法\n\n\n\nimage:\n使用已有镜像\n\n\nbuild:\n用 Dockerfile 构建镜像\n\n\nports:\n本地端口:容器端口\n\n\nvolumes:\n本地路径:容器路径\n\n\nenvironment:\n设置环境变量\n\n\ndepends_on:\n设置服务启动顺序\n\n\nrestart:\n容器崩溃时是否自动重启（如 always、on-failure）\n\n\nnetworks:\n设置自定义网络（可多个服务通信）\n\n\n六、实用命令大全Ubuntu# 启动服务docker-compose up -d # 或者 docker compose up -d# 停止并删除容器docker-compose down # 或者 docker compose down# 查看运行日志docker-compose logs # 或者 docker compose logs# 查看服务状态docker-compose ps # 或者 docker compose ps# 进入容器docker-compose exec 服务名 bash # 或者 docker compose exec 服务名 bash\n\n\n","categories":["服务端","docker"],"tags":["服务端","docker"]},{"title":"Prometheus+Grafana","url":"/2025/03/30/moniter/","content":"简介🔍 Prometheus 是什么？Prometheus 是一个“监控和数据采集系统”，简单理解就是一个“收集数据的仓库+大脑”。\n📦 它主要做这些事：    •\t采集数据：比如服务器的 CPU 使用率、内存占用、网络流量、请求次数等。    •\t存储数据：把这些数据以时间序列的形式存到自己的数据库里。    •\t查询数据：支持用专门的 PromQL 语言查询、筛选、聚合各种指标。    •\t设置告警：可以设置规则，当某个指标异常时触发告警（例如 CPU 连续5分钟超过 90%）。\n👀 简单说，它是“采集、存、查、报”的一套系统，不负责可视化。\n📊 Grafana 是什么？Grafana 是一个数据可视化工具，用来“把数据变成图表”。\n🎨 它主要做这些事：    •\t连接数据源：比如连接 Prometheus，读取里面的指标数据。    •\t绘制图表和仪表盘：你可以用它制作漂亮的图、线、饼图、热图等各种形式。    •\t设置仪表盘：将不同的数据组合成统一的监控面板，便于一眼看出系统健康状况。    •\t告警通知：Grafana 也支持设置告警（但数据还是从 Prometheus 来）。\n👀 简单说，它是“读数 + 画图 + 展示”的一套系统，不负责采集和存储。\n安装步骤一 安装Node Exporter（监控服务器性能）Node Exporter是Prometheus的官方工具，可以帮助采集服务器的硬件指标（CPU、内存、磁盘等）。\nUbuntussh root@你的服务器ipsudo useradd --no-create-home --shell /bin/false node_exporter# 创建node_exporter用户(安全起见)wget https://github.com/prometheus/node_exporter/releases/download/v1.7.0/node_exporter-1.7.0.linux-amd64.tar.gztar xvf node_exporter-1.7.0.linux-amd64.tar.gzsudo cp node_exporter-1.7.0.linux-amd64/node_exporter /usr/local/bin/# 下载并解压node_exportersudo nano /etc/systemd/system/node_exporter.service# 设置systemd启动服务\n写入以下内容\nUbuntu[Unit]Description=Node ExporterAfter=network.target[Service]User=node_exporterExecStart=/usr/local/bin/node_exporter #文件路径[Install]WantedBy=default.target\n启动并设置开机启动\nUbuntusudo systemctl daemon-reexecsudo systemctl start node_exportersudo systemctl enable node_exporter\n测试一下：打开浏览器访问：http:&#x2F;&#x2F;你的服务器IP:9100&#x2F;metrics如果能看到一堆指标文字，说明成功！\n步骤二 安装Prometheus下载Prometheus：\nUbuntuwget https://github.com/prometheus/prometheus/releases/download/v2.50.0/prometheus-2.50.0.linux-amd64.tar.gztar xvf prometheus-2.50.0.linux-amd64.tar.gz # 解压cd prometheus-2.50.0.linux-amd64 # 进入文件夹里面创建.yml文件nano prometheus.yml # 创建prometheus配置文件\n写入一下内容：\nUbuntuglobal:         # 一定要写正确格式，包括空格以及重复定义  scrape_interval: 15sscrape_configs:  - job_name: &#x27;node_exporter&#x27;    static_configs: # 这个可能会有冲突       - targets: [&#x27;localhost:9100&#x27;]   - job_name: &#x27;website_http_check&#x27;    metrics_path: /probe    params:      module: [http_2xx]    static_configs:      - targets:          - http://你的域名或者IP    relabel_configs:      - source_labels: [__address__]        target_label: __param_target      - source_labels: [__param_target]        target_label: instance      - target_label: __address__        replacement: localhost:9115  # blackbox_exporter 监听端口\n\n步骤三 安装Blackbox Exporter(探测网站状态)Ubuntuwget https://github.com/prometheus/blackbox_exporter/releases/download/v0.25.0/blackbox_exporter-0.25.0.linux-amd64.tar.gztar xvf blackbox_exporter-0.25.0.linux-amd64.tar.gzcd blackbox_exporter-0.25.0.linux-amd64 ./blackbox_exporter     # 进入文件夹启动# 也可以添加systemd启动服务，和node_exporter类似。\n\n步骤四 启动prometheusUbuntu./prometheus --config.file=prometheus.yml\n访问浏览器：http:&#x2F;&#x2F;你的服务器IP:9090，你应该可以看到 Prometheus 的 Web 页面。\n📊 步骤五：安装 Grafanasudo apt-get install -y apt-transport-https software-properties-common# 安装依赖 sudo apt-get install -y wgetwget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -echo &quot;deb https://packages.grafana.com/oss/deb stable main&quot; | sudo tee /etc/apt/sources.list.d/grafana.listsudo apt-get update# 添加grafana仓库sudo apt-get install grafanasudo systemctl start grafana-serversudo systemctl enable grafana-server# 安装并启动grafana\n访问grafana：浏览器打开 http:&#x2F;&#x2F;你的服务器IP:3000，默认账号密码是：用户名：admin密码：admin  登录之后会要求修改密码\n📈 步骤六：配置 Grafana添加数据源：选择 Prometheus，填入 http://localhost:9090导入 Dashboard 模板：Node Exporter：导入模板 ID 1860Blackbox 网站状态：导入模板 ID 7587\n使用grafana更改中文要将Grafana配置为中文，你可以参照以下步骤进行操作\n\n打开grafana的默认配置文件：&#x2F;opt&#x2F;bitnami&#x2F;grafana&#x2F;conf&#x2F;defaults.ini                   &#x2F;usr&#x2F;share&#x2F;grafana&#x2F;conf&#x2F;defaults.ini\n在该文件中，找到default_language这一行，将en-US改为zh-Hans。这样grafana的语言就会更改为中文。\n保存并关闭文件\n启服务刷新网页即可systemctl restart grafana-server\n\n监控告警🛠️ 步骤一：设置 Prometheus 告警规则Prometheus 支持基于查询的告警规则，你可以通过 PromQL 设置条件，比如当系统负载过高时发出告警。\n\n创建告警规则文件在 Prometheus 配置目录下创建一个 alert.rules 文件（如果没有的话）：Ubuntunano /etc/prometheus/alert.rules # 看你prometheus安装/解压到了哪里\n在文件中加入告警规则，例如：Yamlgroups:  - name: node_alerts    rules:    - alert: HighCPUUsage       expr: 100 * (1 - avg by (instance) (rate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[1m]))) &gt; 80      for: 5m      labels:        severity: critical      annotations:        summary: &quot;CPU usage is above 80% on &#123;&#123; $labels.instance &#125;&#125;&quot;        description: &quot;CPU usage is above 80% for 5 minutes on &#123;&#123; $labels.instance &#125;&#125;.&quot;            - alert: HighLoadAverage      expr: node_load1 &gt; 2      for: 5m      labels:        severity: critical      annotations:        summary: &quot;High load average on &#123;&#123; $labels.instance &#125;&#125;&quot;        description: &quot;The 1-minute load average is above 2 on &#123;&#123; $labels.instance &#125;&#125;.&quot;\nHighCPUUsage：当 CPU 使用率超过 80% 持续 5 分钟时，触发告警。HighLoadAverage：当系统 1 分钟平均负载超过 2 时，触发告警。\n修改 Prometheus 配置文件，加载告警规则编辑 Prometheus 配置文件 prometheus.yml，加入规则文件：Ubunturule_files:  - &quot;/etc/prometheus/alert.rules&quot;\n重新启动 Prometheus\n\n修改完配置后，重新启动 Prometheus 服务来应用告警规则：\nsudo systemctl restart prometheus\n🛠️ 步骤二：配置 Grafana 告警通知一旦 Prometheus 设置了告警规则，你就可以在 Grafana 中查看告警并设置通知。\n\n设置通知渠道\n\n首先需要在 Grafana 配置一个通知渠道，常用的有 邮件、钉钉、Slack 等。\n配置邮件通知    1.\t打开 Grafana UI，进入 “Alerting” &gt; “Notification channels”。    2.\t点击 “Add channel”。    3.\t选择通知方式（比如 Email）并填写相关信息：    •\tEmail Address：收件人邮箱    •\tSMTP：配置发送邮件的 SMTP 服务（如 Gmail 或自己配置的 SMTP）\n配置钉钉&#x2F;Slack 通知\n你可以选择使用钉钉或 Slack 的 Webhook，步骤类似，直接填写 Webhook URL。\n\n配置告警规则\n\n在 Grafana 中，进入你要监控的 Dashboard，并进行告警设置：    1.\t打开需要设置告警的图表，点击图表右上角的 “Alert” 标签。    2.\t配置告警条件，比如：    •\t当系统负载超过某个阈值。    •\t配置告警时间（比如 5 分钟内触发）。    3.\t在 “Notifications” 部分，选择之前配置好的通知渠道（比如 Email、钉钉等）。\n\n保存告警设置\n\n设置完成后，点击 “Save” 来保存告警规则。Grafana 会根据你设置的条件，定期检查，并在触发告警时通过邮件或钉钉等渠道发送通知。\n🧑‍💻 步骤三：验证告警是否有效\n要让 Grafana 能通过 SMTP 发送邮件告警通知，你需要配置它的 smtp 邮件发送服务。以Gmail为例\n\n\n\n\n配置项\n示例（以 Gmail 为例）\n\n\n\nSMTP 服务器地址\nsmtp.gmail.com\n\n\n端口号\n587 (TLS) &#x2F; 465 (SSL)\n\n\n发件邮箱\n&#121;&#111;&#x75;&#x72;&#110;&#x61;&#x6d;&#101;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;\n\n\n发件邮箱密码\nGmail 生成的“应用专用密码”\n\n\n接收人邮箱\n任意你想收到告警的人邮箱地址\n\n\n\n修改 Grafana 配置文件 grafana.ini默认路径通常是：nano /etc/grafana/grafana.ini\n找到以下配置段落，把它修改成你的信息（注意取消注释）：ini#################################### SMTP / Emailing ##########################[smtp]enabled = truehost = smtp.gmail.com:587user = yourname@gmail.compassword = your_app_password   ; # Gmail 需要使用“应用专用密码”而不是登录密码;cert_file =;key_file =skip_verify = falsefrom_address = yourname@gmail.comfrom_name = Grafana Monitor[emails];welcome_email_on_sign_up = false\n💡如果你使用的是 QQ 邮箱、阿里邮箱、163 等都可以，改下 host、端口、密码即可\n🔐 关于 Gmail 的“应用专用密码”：\n   登录你的 Gmail 账号\n   打开： https://myaccount.google.com/security\n   开启 两步验证\n   找到“应用专用密码”，创建一个密码用于 Grafana 发送邮件\n   拷贝该密码，贴到上面 password 一栏中\n\n\n🔄重启 Grafana 服务配置改好之后需要重启 Grafana 才能生效：sudo systemctl restart grafana-server\n✉️在 Grafana 中测试发送邮件\n   登录 Grafana → 左侧点击 “Alerting” → “Contact points”\n   创建一个新的 Email 通知方式\n   输入你希望接收告警的邮箱地址\n   保存后点击 “Send test notification” 来验证是否能收到邮件\n\n\n\n✅ 如果设置成功，你应该会在邮箱里看到一个测试邮件！\n🎉 完成！\n","categories":["运维","监控","Prometheus+Grafana"],"tags":["运维","监控"]},{"title":"DevOps 世界的灵魂技术：CI/CD 流水线","url":"/2025/04/13/CI-CD/","content":"DevOps 世界的灵魂技术：CI&#x2F;CD 流水线\n什么是 CI&#x2F;CD 流水线CI&#x2F;CD &#x3D; 持续集成 + 持续交付 &#x2F; 持续部署是一整套“自动化流水线”，用来让软件开发从提交代码 → 自动构建 → 自动测试 → 自动部署，一条龙完成\nCI&#x2F;CD 是干嘛的你写代码 → 推送到 GitHub / GitLab           ↓      ✅ CI 阶段（持续集成）      - 自动编译打包      - 自动跑单元测试      - 自动代码检查           ↓      🚀 CD 阶段（持续交付 / 部署）      - 自动构建 Docker 镜像      - 自动发布到测试 / 生产环境      - 自动通知（钉钉 / Slack）\nCI&#x2F;CD 各阶段都干了啥？\n\n\n阶段\n中文名\n做什么举动？\n\n\n\nCI（持续集成）\nContinuous Integration\n自动测试 + 打包构建\n\n\nCD（持续交付）\nContinuous Delivery\n自动发布到测试环境，人工确认上线\n\n\nCD（持续部署）\nContinuous Deployment\n自动发布到生产环境，无人工干预\n\n\n典型的流水线长这样\n\n# Gitlab CI 示例 .gitlab-ci.ymlstages:    - build    - test    - deploybuild:    stage: build    script:        - npm install         - npm run build    artifacts:        path:            - dist/test:    stage: test    script:        - npm testdeploy:    stage: deploy    script:        - docker build -t my-app .        - docker push myregistry.com/my-app        - ssh deploy@server &#x27;docker pull my-app &amp;&amp; docker restart my-app&#x27;\n🛠 常用 CI&#x2F;CD 工具平台有哪些？\n\n\n工具\n说明\n推荐指数\n\n\n\nGitHub Actions\nGitHub 原生支持，简单易上手\n⭐⭐⭐⭐⭐\n\n\nGitLab CI&#x2F;CD\nGitLab 自带 CI&#x2F;CD，集成度高\n⭐⭐⭐⭐\n\n\nJenkins\n开源界老牌 CI&#x2F;CD 工具\n⭐⭐⭐⭐（适合自定义复杂流程）\n\n\nGitea + Drone\n私有部署组合\n⭐⭐⭐\n\n\nCircleCI &#x2F; Travis CI\n国外流行，GitHub 项目多\n⭐⭐⭐（限免费额度）\n\n\n💡 现实例子：部署一个 Vue 项目 + 后端服务\n\n\n开发人员提交代码到 GitHub\nGitHub Actions 自动触发：•\t运行测试•\t执行构建（npm run build）•\t打包为 Docker 镜像•\t推送到 Docker Hub &#x2F; 私有仓库•\tSSH 登录服务器远程部署 &#x2F; 使用 K8s 滚动更新•\t通知钉钉 &#x2F; 邮件群“部署完成”\n\n🎉 全程不用你手点，自动完成\nCI&#x2F;CD 的价值总结\n\n\n好处\n描述\n\n\n\n🧹 降低人为错误\n减少部署出错、环境不一致等问题\n\n\n🚀 加快迭代速度\n提交代码后几分钟就能上线\n\n\n📦 提高质量\n每次提交都跑测试，代码更稳定\n\n\n🤝 提升团队协作\n所有人按统一标准部署，不容易混乱\n\n\n🔄 易于回滚\n版本打包有记录，可随时切回\n\n\n使用以此博客作为实战项目。使用GitHub Actions作为流水线工具🔧\n\n目标是什么？实现一件事：我改完博客内容，push 到 GitHub，服务器自动更新上线，不用我点压缩、FTP！\n目前的工具组合\n\n\n工具\n用法\n说明\n\n\n\nGitHub + GitHub Actions\n托管代码 + 执行 CI&#x2F;CD 流水线\n免费、好用\n\n\nSSH + rsync\n自动远程上传代码\n替代 FTP，更快更稳\n\n\nNginx\n你已经部署好了，用作 Web 服务\n根目录挂载网站内容\n\n\n\n\n目录结构如果没有workflows 需要手动创建！\n我的博客/├── .github/│   └── workflows/│       └── deploy.yml      👈 GitHub Actions 流水线脚本│   └── dependabot.yml      ├── public/                 👈 构建后输出目录├── package.json / config.yml\nGitHub Actions自动部署脚本name: 自动部署博客到服务器on:    push:        branches:            - main  # 使用的分支，如果是master 修改这里jobs:    deploy:        runs-on: ubuntu-latest        steps:            - name: 拉代码              uses: actions/checkout@v3            - name: 安装Node.js               uses: actions/setup-node@v3              with:                node-version: 18                               - name: 安装依赖 &amp; 构建博客               run: |                npm install                 npm install -g hexo-cli                npx hexo generate            # 如果只需要上传资源到服务器 可以省去安装node 和hexo的依赖            - name: 上传到服务器              uses: easingthemes/ssh-deploy@v2.1.5              with:                SSH_PRIVATE_KEY: $&#123;&#123; secrets.SERVER_SSH_KEY &#125;&#125;                REMOTE_USER: root   # 你的服务器用户名                REMOTE_HOST: x.x.x.x    # 你的服务器IP                TARGET: /var/www/html   # 你nginx的根目录 写到根上一个文件夹                SOURCE: public/         # 你网页的资源                \n配置服务器 SSH 密钥\n在本地执行命令生成密钥：ssh-keygen -t rsa -b 4096 -C &quot;you@example.com&quot;\n拷贝公钥到服务器：ssh-copy-id your_user@your.server.ip\n或者手动把 ～&#x2F;.ssh&#x2F;id_rsa.pub的内容追加到服务器的：~/.ssh/authorized_keys\n把私钥~&#x2F;.ssh&#x2F;id_rsa 的内容复制，粘贴到 GitHub 仓库中：GitHub → Settings → Secrets → Actions → New repository secret名字叫：SERVER_SSH_KEY值是你私钥的内容（注意安全，不要泄露）\n\n修改 REMOTE_USER、REMOTE_HOST、TARGET比如你服务器用户名是 root，公网 IP 是 1.2.3.4，部署路径是 &#x2F;var&#x2F;www&#x2F;html，那你就填\nREMOTE_USER: rootREMOTE_HOST: 1.2.3.4TARGET: /var/www/html\n\n最后 推送试试！git add .git commit -m &quot;首次添加自动部署&quot;git push origin main\n🌟 然后进入 GitHub → Actions，就能看到它自动执行！\n部署成功后，你就可以访问 http:&#x2F;&#x2F; your.server.ip 查看效果！💡 小建议：可选加一行日志打印\n- name: 查看构建结果文件夹  run: ls -al public/ "}]